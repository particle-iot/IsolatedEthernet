<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IsolatedEthernet: IsolatedEthernet::TCPClient Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IsolatedEthernet
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="class_isolated_ethernet.html">IsolatedEthernet</a></li><li class="navelem"><a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html">TCPClient</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle"><div class="title">IsolatedEthernet::TCPClient Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html" title="TCPClient class used to access the isolated Ethernet.">TCPClient</a> class used to access the isolated Ethernet.  
 <a href="class_isolated_ethernet_1_1_t_c_p_client.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_isolated_ethernet_8h_source.html">IsolatedEthernet.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for IsolatedEthernet::TCPClient:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_isolated_ethernet_1_1_t_c_p_client.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae3efdc8291484c28b79d6533e1768409"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#ae3efdc8291484c28b79d6533e1768409">TCPClient</a> ()</td></tr>
<tr class="memdesc:ae3efdc8291484c28b79d6533e1768409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html" title="TCPClient class used to access the isolated Ethernet.">TCPClient</a> object. You will do this for each TCP client connection.  <a href="class_isolated_ethernet_1_1_t_c_p_client.html#ae3efdc8291484c28b79d6533e1768409">More...</a><br /></td></tr>
<tr class="separator:ae3efdc8291484c28b79d6533e1768409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385ab02fd6affd6d57afe925e3747e29"><td class="memItemLeft" align="right" valign="top"><a id="a385ab02fd6affd6d57afe925e3747e29" name="a385ab02fd6affd6d57afe925e3747e29"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TCPClient</b> (sock_handle_t sock)</td></tr>
<tr class="memdesc:a385ab02fd6affd6d57afe925e3747e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html" title="TCPClient class used to access the isolated Ethernet.">TCPClient</a> object. You will not generally use this overload, it's used internally. <br /></td></tr>
<tr class="separator:a385ab02fd6affd6d57afe925e3747e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e73b10c38158515d33a761bba83e52b"><td class="memItemLeft" align="right" valign="top"><a id="a5e73b10c38158515d33a761bba83e52b" name="a5e73b10c38158515d33a761bba83e52b"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~TCPClient</b> ()</td></tr>
<tr class="memdesc:a5e73b10c38158515d33a761bba83e52b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the <a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html" title="TCPClient class used to access the isolated Ethernet.">TCPClient</a> object. This will close the connection if necessary and release its resources. <br /></td></tr>
<tr class="separator:a5e73b10c38158515d33a761bba83e52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68839ec4bac11e656513ac57370a640a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#a68839ec4bac11e656513ac57370a640a">status</a> ()</td></tr>
<tr class="memdesc:a68839ec4bac11e656513ac57370a640a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the network socket is open and the underlying network is ready.  <a href="class_isolated_ethernet_1_1_t_c_p_client.html#a68839ec4bac11e656513ac57370a640a">More...</a><br /></td></tr>
<tr class="separator:a68839ec4bac11e656513ac57370a640a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e59ece5e587dfaa488e8754c49dc4f"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#ac1e59ece5e587dfaa488e8754c49dc4f">connect</a> (IPAddress ip, uint16_t port, network_interface_t=0)</td></tr>
<tr class="memdesc:ac1e59ece5e587dfaa488e8754c49dc4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to a host by IP address.  <a href="class_isolated_ethernet_1_1_t_c_p_client.html#ac1e59ece5e587dfaa488e8754c49dc4f">More...</a><br /></td></tr>
<tr class="separator:ac1e59ece5e587dfaa488e8754c49dc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a66de81e65523edf1d80b7c0cc7c67b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#a5a66de81e65523edf1d80b7c0cc7c67b">connect</a> (const char *host, uint16_t port, network_interface_t=0)</td></tr>
<tr class="memdesc:a5a66de81e65523edf1d80b7c0cc7c67b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to a host by its DNS hostname.  <a href="class_isolated_ethernet_1_1_t_c_p_client.html#a5a66de81e65523edf1d80b7c0cc7c67b">More...</a><br /></td></tr>
<tr class="separator:a5a66de81e65523edf1d80b7c0cc7c67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7593d5374e5eebf774c4d3d551a837"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#aab7593d5374e5eebf774c4d3d551a837">write</a> (uint8_t b)</td></tr>
<tr class="memdesc:aab7593d5374e5eebf774c4d3d551a837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a single byte to the remote host.  <a href="class_isolated_ethernet_1_1_t_c_p_client.html#aab7593d5374e5eebf774c4d3d551a837">More...</a><br /></td></tr>
<tr class="separator:aab7593d5374e5eebf774c4d3d551a837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e463d7fc2d6cd8b6f3069553095f97"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#aa4e463d7fc2d6cd8b6f3069553095f97">write</a> (const uint8_t *buffer, size_t size)</td></tr>
<tr class="memdesc:aa4e463d7fc2d6cd8b6f3069553095f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a buffer of data to the remote host.  <a href="class_isolated_ethernet_1_1_t_c_p_client.html#aa4e463d7fc2d6cd8b6f3069553095f97">More...</a><br /></td></tr>
<tr class="separator:aa4e463d7fc2d6cd8b6f3069553095f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2607c60404cbe4562f438a377a55e7e"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#ae2607c60404cbe4562f438a377a55e7e">write</a> (uint8_t b, system_tick_t timeout)</td></tr>
<tr class="memdesc:ae2607c60404cbe4562f438a377a55e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a single byte to the remote host.  <a href="class_isolated_ethernet_1_1_t_c_p_client.html#ae2607c60404cbe4562f438a377a55e7e">More...</a><br /></td></tr>
<tr class="separator:ae2607c60404cbe4562f438a377a55e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba86c51dc3613021d95cbeb943f1c7f8"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#aba86c51dc3613021d95cbeb943f1c7f8">write</a> (const uint8_t *buffer, size_t size, system_tick_t timeout)</td></tr>
<tr class="memdesc:aba86c51dc3613021d95cbeb943f1c7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a buffer of data to the remote host.  <a href="class_isolated_ethernet_1_1_t_c_p_client.html#aba86c51dc3613021d95cbeb943f1c7f8">More...</a><br /></td></tr>
<tr class="separator:aba86c51dc3613021d95cbeb943f1c7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14af3e17720ef42e7ab2735c7fe53964"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#a14af3e17720ef42e7ab2735c7fe53964">available</a> ()</td></tr>
<tr class="memdesc:a14af3e17720ef42e7ab2735c7fe53964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes available to read.  <a href="class_isolated_ethernet_1_1_t_c_p_client.html#a14af3e17720ef42e7ab2735c7fe53964">More...</a><br /></td></tr>
<tr class="separator:a14af3e17720ef42e7ab2735c7fe53964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2356a6321a7d43f70b1eb2d73434b592"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#a2356a6321a7d43f70b1eb2d73434b592">read</a> ()</td></tr>
<tr class="memdesc:a2356a6321a7d43f70b1eb2d73434b592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single byte from the receive buffer.  <a href="class_isolated_ethernet_1_1_t_c_p_client.html#a2356a6321a7d43f70b1eb2d73434b592">More...</a><br /></td></tr>
<tr class="separator:a2356a6321a7d43f70b1eb2d73434b592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fd9a31fe176fa4c238c2dbbbc7153a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#a17fd9a31fe176fa4c238c2dbbbc7153a">read</a> (uint8_t *buffer, size_t size)</td></tr>
<tr class="memdesc:a17fd9a31fe176fa4c238c2dbbbc7153a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a buffer of data from the receive buffer.  <a href="class_isolated_ethernet_1_1_t_c_p_client.html#a17fd9a31fe176fa4c238c2dbbbc7153a">More...</a><br /></td></tr>
<tr class="separator:a17fd9a31fe176fa4c238c2dbbbc7153a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f447b5cac944eb462a79ce605a7a78d"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#a7f447b5cac944eb462a79ce605a7a78d">peek</a> ()</td></tr>
<tr class="memdesc:a7f447b5cac944eb462a79ce605a7a78d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look at the next byte will be read, without removing it from the input buffer.  <a href="class_isolated_ethernet_1_1_t_c_p_client.html#a7f447b5cac944eb462a79ce605a7a78d">More...</a><br /></td></tr>
<tr class="separator:a7f447b5cac944eb462a79ce605a7a78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1198865c8b44b74074d931ad73464c"><td class="memItemLeft" align="right" valign="top"><a id="a7b1198865c8b44b74074d931ad73464c" name="a7b1198865c8b44b74074d931ad73464c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>flush</b> ()</td></tr>
<tr class="memdesc:a7b1198865c8b44b74074d931ad73464c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks until all data waiting to be sent in the W5500 send buffer has been sent. <br /></td></tr>
<tr class="separator:a7b1198865c8b44b74074d931ad73464c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d915bd349dbb0f6d8615840e55a8e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#a27d915bd349dbb0f6d8615840e55a8e9">flush_buffer</a> ()</td></tr>
<tr class="memdesc:a27d915bd349dbb0f6d8615840e55a8e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discards data waiting to be read from the internal buffer.  <a href="class_isolated_ethernet_1_1_t_c_p_client.html#a27d915bd349dbb0f6d8615840e55a8e9">More...</a><br /></td></tr>
<tr class="separator:a27d915bd349dbb0f6d8615840e55a8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf07276834f38f3d5d5d24988b6331da"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#acf07276834f38f3d5d5d24988b6331da">stop</a> ()</td></tr>
<tr class="memdesc:acf07276834f38f3d5d5d24988b6331da"><td class="mdescLeft">&#160;</td><td class="mdescRight">End this connection, release its resources.  <a href="class_isolated_ethernet_1_1_t_c_p_client.html#acf07276834f38f3d5d5d24988b6331da">More...</a><br /></td></tr>
<tr class="separator:acf07276834f38f3d5d5d24988b6331da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e68d530cb2132327e38806c6acd348"><td class="memItemLeft" align="right" valign="top">virtual uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#a20e68d530cb2132327e38806c6acd348">connected</a> ()</td></tr>
<tr class="memdesc:a20e68d530cb2132327e38806c6acd348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there is data waiting to be read or if currently connected to the remote host.  <a href="class_isolated_ethernet_1_1_t_c_p_client.html#a20e68d530cb2132327e38806c6acd348">More...</a><br /></td></tr>
<tr class="separator:a20e68d530cb2132327e38806c6acd348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5aaabde4d7e17556af599fbc54266e0"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#ad5aaabde4d7e17556af599fbc54266e0">operator bool</a> ()</td></tr>
<tr class="memdesc:ad5aaabde4d7e17556af599fbc54266e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#a68839ec4bac11e656513ac57370a640a" title="Returns true if the network socket is open and the underlying network is ready.">status()</a> != 0, but as the bool() operator, making it easy to test if there is a connection.  <a href="class_isolated_ethernet_1_1_t_c_p_client.html#ad5aaabde4d7e17556af599fbc54266e0">More...</a><br /></td></tr>
<tr class="separator:ad5aaabde4d7e17556af599fbc54266e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf117a93d56d4f3fd198f7b329e0d89"><td class="memItemLeft" align="right" valign="top">virtual IPAddress&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#afdf117a93d56d4f3fd198f7b329e0d89">remoteIP</a> ()</td></tr>
<tr class="memdesc:afdf117a93d56d4f3fd198f7b329e0d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the IP address of the other side of the connection.  <a href="class_isolated_ethernet_1_1_t_c_p_client.html#afdf117a93d56d4f3fd198f7b329e0d89">More...</a><br /></td></tr>
<tr class="separator:afdf117a93d56d4f3fd198f7b329e0d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9195b97274029f693aaddce6c7a0021"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#ab9195b97274029f693aaddce6c7a0021">write</a> (uint8_t c)=0</td></tr>
<tr class="memdesc:ab9195b97274029f693aaddce6c7a0021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a single byte to the stream or file.  <a href="class_isolated_ethernet_1_1_t_c_p_client.html#ab9195b97274029f693aaddce6c7a0021">More...</a><br /></td></tr>
<tr class="separator:ab9195b97274029f693aaddce6c7a0021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b40e0e9cab1f2fe5bb0cb22ffe5adda"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#a5b40e0e9cab1f2fe5bb0cb22ffe5adda">write</a> (const char *str)</td></tr>
<tr class="memdesc:a5b40e0e9cab1f2fe5bb0cb22ffe5adda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a null-terminated c-string the stream or file.  <a href="class_isolated_ethernet_1_1_t_c_p_client.html#a5b40e0e9cab1f2fe5bb0cb22ffe5adda">More...</a><br /></td></tr>
<tr class="separator:a5b40e0e9cab1f2fe5bb0cb22ffe5adda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88864e109589a5be9b0f5ba1327f8421"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#a88864e109589a5be9b0f5ba1327f8421">write</a> (const uint8_t *buffer, size_t size)</td></tr>
<tr class="memdesc:a88864e109589a5be9b0f5ba1327f8421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a bytes specified by a buffer and length to the stream or file.  <a href="class_isolated_ethernet_1_1_t_c_p_client.html#a88864e109589a5be9b0f5ba1327f8421">More...</a><br /></td></tr>
<tr class="separator:a88864e109589a5be9b0f5ba1327f8421"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9692f513b5e85d0d3fc3dcfecd1d7d71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#a9692f513b5e85d0d3fc3dcfecd1d7d71">isOpen</a> ()</td></tr>
<tr class="memdesc:a9692f513b5e85d0d3fc3dcfecd1d7d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true of the socket is currently open. Used internally.  <a href="class_isolated_ethernet_1_1_t_c_p_client.html#a9692f513b5e85d0d3fc3dcfecd1d7d71">More...</a><br /></td></tr>
<tr class="separator:a9692f513b5e85d0d3fc3dcfecd1d7d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb30c04c770172fbc6720f5242e3d82"><td class="memItemLeft" align="right" valign="top">sock_handle_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#a3cb30c04c770172fbc6720f5242e3d82">sock_handle</a> ()</td></tr>
<tr class="memdesc:a3cb30c04c770172fbc6720f5242e3d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used internally to access the socket handle for this connection.  <a href="class_isolated_ethernet_1_1_t_c_p_client.html#a3cb30c04c770172fbc6720f5242e3d82">More...</a><br /></td></tr>
<tr class="separator:a3cb30c04c770172fbc6720f5242e3d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a91068d96c769b8b2ad09502687b70f6e"><td class="memItemLeft" align="right" valign="top"><a id="a91068d96c769b8b2ad09502687b70f6e" name="a91068d96c769b8b2ad09502687b70f6e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>IsolatedEthernet::TCPServer</b></td></tr>
<tr class="separator:a91068d96c769b8b2ad09502687b70f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p ><a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html" title="TCPClient class used to access the isolated Ethernet.">TCPClient</a> class used to access the isolated Ethernet. </p>
<p >Replace <code><a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html" title="TCPClient class used to access the isolated Ethernet.">TCPClient</a></code> with <code><a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html" title="TCPClient class used to access the isolated Ethernet.">IsolatedEthernet::TCPClient</a></code> to use Ethernet instead of the Particle device's native networking (cellular or Wi-Fi). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae3efdc8291484c28b79d6533e1768409" name="ae3efdc8291484c28b79d6533e1768409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3efdc8291484c28b79d6533e1768409">&#9670;&nbsp;</a></span>TCPClient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IsolatedEthernet::TCPClient::TCPClient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html" title="TCPClient class used to access the isolated Ethernet.">TCPClient</a> object. You will do this for each TCP client connection. </p>
<p >There is a limit of 8 connections (TCP, <a class="el" href="class_isolated_ethernet_1_1_u_d_p.html" title="Replacement for UDP class to use Ethernet.">UDP</a>, DNS, DHCP) at a time on the W5500. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a14af3e17720ef42e7ab2735c7fe53964" name="a14af3e17720ef42e7ab2735c7fe53964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14af3e17720ef42e7ab2735c7fe53964">&#9670;&nbsp;</a></span>available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int IsolatedEthernet::TCPClient::available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bytes available to read. </p>
<dl class="section return"><dt>Returns</dt><dd>int number of bytes</dd></dl>
<p>Note that the receive buffer is only 2048 bytes on the W5500. Thus the other side of the connection may be holding more data that has not been received by the W5500 yet.</p>
<p >If you are expecting a fixed-size structure, you should always read out all available bytes on each loop into a separate buffer and process when it has been read completely. Do not wait for <a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#a14af3e17720ef42e7ab2735c7fe53964" title="Returns the number of bytes available to read.">available()</a> to be the size of the structure then read. </p>

</div>
</div>
<a id="a5a66de81e65523edf1d80b7c0cc7c67b" name="a5a66de81e65523edf1d80b7c0cc7c67b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a66de81e65523edf1d80b7c0cc7c67b">&#9670;&nbsp;</a></span>connect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int IsolatedEthernet::TCPClient::connect </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">network_interface_t&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect to a host by its DNS hostname. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>the hostname to connect to </td></tr>
    <tr><td class="paramname">port</td><td>The IP port number to connect to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int true (1) if the connection was made or false (0) if not.</dd></dl>
<p>This call will block until the connection is made or times out.</p>
<p >Note that every connection will cause a DNS lookup when connecting by hostname; there is no DNS cache. </p>

</div>
</div>
<a id="ac1e59ece5e587dfaa488e8754c49dc4f" name="ac1e59ece5e587dfaa488e8754c49dc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e59ece5e587dfaa488e8754c49dc4f">&#9670;&nbsp;</a></span>connect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int IsolatedEthernet::TCPClient::connect </td>
          <td>(</td>
          <td class="paramtype">IPAddress&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">network_interface_t&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect to a host by IP address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>The IP address to connect to </td></tr>
    <tr><td class="paramname">port</td><td>The IP port number to connect to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int true (1) if the connection was made or false (0) if not.</dd></dl>
<p>This call will block until the connection is made or times out. </p>

</div>
</div>
<a id="a20e68d530cb2132327e38806c6acd348" name="a20e68d530cb2132327e38806c6acd348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e68d530cb2132327e38806c6acd348">&#9670;&nbsp;</a></span>connected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint8_t IsolatedEthernet::TCPClient::connected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if there is data waiting to be read or if currently connected to the remote host. </p>
<dl class="section return"><dt>Returns</dt><dd>uint8_t If data available or connected</dd></dl>
<p>This is different than <a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#a68839ec4bac11e656513ac57370a640a" title="Returns true if the network socket is open and the underlying network is ready.">status()</a> which only checks whether the connection is open, which seems kind of backwards, but that's how the Wiring API works. </p>

</div>
</div>
<a id="a27d915bd349dbb0f6d8615840e55a8e9" name="a27d915bd349dbb0f6d8615840e55a8e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d915bd349dbb0f6d8615840e55a8e9">&#9670;&nbsp;</a></span>flush_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IsolatedEthernet::TCPClient::flush_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discards data waiting to be read from the internal buffer. </p>
<p >There may still be data in the W5500 buffers. </p>

</div>
</div>
<a id="a9692f513b5e85d0d3fc3dcfecd1d7d71" name="a9692f513b5e85d0d3fc3dcfecd1d7d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9692f513b5e85d0d3fc3dcfecd1d7d71">&#9670;&nbsp;</a></span>isOpen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsolatedEthernet::TCPClient::isOpen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true of the socket is currently open. Used internally. </p>
<dl class="section return"><dt>Returns</dt><dd>true </dd>
<dd>
false </dd></dl>

</div>
</div>
<a id="ad5aaabde4d7e17556af599fbc54266e0" name="ad5aaabde4d7e17556af599fbc54266e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5aaabde4d7e17556af599fbc54266e0">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual IsolatedEthernet::TCPClient::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#a68839ec4bac11e656513ac57370a640a" title="Returns true if the network socket is open and the underlying network is ready.">status()</a> != 0, but as the bool() operator, making it easy to test if there is a connection. </p>
<dl class="section return"><dt>Returns</dt><dd>true </dd>
<dd>
false</dd></dl>
<p>This is particularly useful with <a class="el" href="class_isolated_ethernet_1_1_t_c_p_server.html" title="Replacement for TCPServer class to use Ethernet.">TCPServer</a> <a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#a14af3e17720ef42e7ab2735c7fe53964" title="Returns the number of bytes available to read.">available()</a>. </p>

</div>
</div>
<a id="a7f447b5cac944eb462a79ce605a7a78d" name="a7f447b5cac944eb462a79ce605a7a78d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f447b5cac944eb462a79ce605a7a78d">&#9670;&nbsp;</a></span>peek()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int IsolatedEthernet::TCPClient::peek </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look at the next byte will be read, without removing it from the input buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>int The returned byte (0-255), or -1 if there is no data to be read </dd></dl>

</div>
</div>
<a id="a2356a6321a7d43f70b1eb2d73434b592" name="a2356a6321a7d43f70b1eb2d73434b592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2356a6321a7d43f70b1eb2d73434b592">&#9670;&nbsp;</a></span>read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int IsolatedEthernet::TCPClient::read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a single byte from the receive buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>int The returned byte (0-255), or -1 if there is no data to be read</dd></dl>
<p>It's much more efficient to use the overload that takes a buffer and size than reading bytes one at a time. </p>

</div>
</div>
<a id="a17fd9a31fe176fa4c238c2dbbbc7153a" name="a17fd9a31fe176fa4c238c2dbbbc7153a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17fd9a31fe176fa4c238c2dbbbc7153a">&#9670;&nbsp;</a></span>read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int IsolatedEthernet::TCPClient::read </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a buffer of data from the receive buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer to read data into </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to read, must be &gt; 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int the number of bytes read, or a negative value on error</dd></dl>
<p>This is much more efficient to read data into a buffer using this call instead of reading one byte at a time. The number of bytes read is not guaranteed to be size requested; if any bytes are available they will be copied to buffer and the result will be the number of bytes actually read.</p>
<p >The optimize request size is 2048 bytes, which is the size of the incoming data buffer. Making it larger will have no effect since there will never be more bytes in the buffer. </p>

</div>
</div>
<a id="afdf117a93d56d4f3fd198f7b329e0d89" name="afdf117a93d56d4f3fd198f7b329e0d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf117a93d56d4f3fd198f7b329e0d89">&#9670;&nbsp;</a></span>remoteIP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual IPAddress IsolatedEthernet::TCPClient::remoteIP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the IP address of the other side of the connection. </p>
<dl class="section return"><dt>Returns</dt><dd>IPAddress </dd></dl>

</div>
</div>
<a id="a3cb30c04c770172fbc6720f5242e3d82" name="a3cb30c04c770172fbc6720f5242e3d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb30c04c770172fbc6720f5242e3d82">&#9670;&nbsp;</a></span>sock_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sock_handle_t IsolatedEthernet::TCPClient::sock_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used internally to access the socket handle for this connection. </p>
<dl class="section return"><dt>Returns</dt><dd>sock_handle_t A W5500 socket handle (0 - 7) or -1 if there isn't an open socket. </dd></dl>

</div>
</div>
<a id="a68839ec4bac11e656513ac57370a640a" name="a68839ec4bac11e656513ac57370a640a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68839ec4bac11e656513ac57370a640a">&#9670;&nbsp;</a></span>status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t IsolatedEthernet::TCPClient::status </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the network socket is open and the underlying network is ready. </p>
<dl class="section return"><dt>Returns</dt><dd>uint8_t 1 if the network socket is open or 0 if not, essentially a boolean.</dd></dl>
<p>This is different than <a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#a20e68d530cb2132327e38806c6acd348" title="Returns true if there is data waiting to be read or if currently connected to the remote host.">connected()</a> which returns true if the socket is closed but there is still unread buffered data, <a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#a14af3e17720ef42e7ab2735c7fe53964" title="Returns the number of bytes available to read.">available()</a> is non-zero. </p>

</div>
</div>
<a id="acf07276834f38f3d5d5d24988b6331da" name="acf07276834f38f3d5d5d24988b6331da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf07276834f38f3d5d5d24988b6331da">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IsolatedEthernet::TCPClient::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End this connection, release its resources. </p>
<p >The Wiring API for streams is not particularly well-suited for TCP as it doesn't have a clear concept of half-closed connections. </p>

</div>
</div>
<a id="a5b40e0e9cab1f2fe5bb0cb22ffe5adda" name="a5b40e0e9cab1f2fe5bb0cb22ffe5adda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b40e0e9cab1f2fe5bb0cb22ffe5adda">&#9670;&nbsp;</a></span>write() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Print::write </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a null-terminated c-string the stream or file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>point to a null-terminated c-string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4e463d7fc2d6cd8b6f3069553095f97" name="aa4e463d7fc2d6cd8b6f3069553095f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e463d7fc2d6cd8b6f3069553095f97">&#9670;&nbsp;</a></span>write() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t IsolatedEthernet::TCPClient::write </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a buffer of data to the remote host. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Pointer to a buffer of bytes to send (can be binary or ASCII) </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t The number of bytes written, typically 1.</dd></dl>
<p>Internally, the W5500 can't buffer more than 2048 bytes of data, however this library will break up your send into chunks to fit in the available buffer space.</p>
<p >This overload does not take a timeout and uses the default timeout of 30 seconds. The timeout is for the whole send, not individual chunks. If the timeout is exceeded there is no guarantee of how many bytes were actually sent.</p>
<p >There's a bug in Device OS where the write function can also return a negative error code from <a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#aab7593d5374e5eebf774c4d3d551a837" title="Writes a single byte to the remote host.">write()</a>, however size_t is unsigned, so it tends to return as a very large positive integer instead. Because of this, it's best to ignore the result or test for != 1. </p>

</div>
</div>
<a id="a88864e109589a5be9b0f5ba1327f8421" name="a88864e109589a5be9b0f5ba1327f8421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88864e109589a5be9b0f5ba1327f8421">&#9670;&nbsp;</a></span>write() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Print::write </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a bytes specified by a buffer and length to the stream or file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>pointer to the buffer. The data does not need to be null-terminated. </td></tr>
    <tr><td class="paramname">size</td><td>size in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba86c51dc3613021d95cbeb943f1c7f8" name="aba86c51dc3613021d95cbeb943f1c7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba86c51dc3613021d95cbeb943f1c7f8">&#9670;&nbsp;</a></span>write() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t IsolatedEthernet::TCPClient::write </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">system_tick_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a buffer of data to the remote host. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Pointer to a buffer of bytes to send (can be binary or ASCII) </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to send. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in milliseconds, or 0 to wait forever</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t The number of bytes written, typically 1.</dd></dl>
<p>Internally, the W5500 can't buffer more than 2048 bytes of data, however this library will break up your send into chunks to fit in the available buffer space.</p>
<p >The timeout is for the whole send, not individual chunks. If the timeout is exceeded there is no guarantee of how many bytes were actually sent.</p>
<p >There's a bug in Device OS where the write function can also return a negative error code from <a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#aab7593d5374e5eebf774c4d3d551a837" title="Writes a single byte to the remote host.">write()</a>, however size_t is unsigned, so it tends to return as a very large positive integer instead. Because of this, it's best to ignore the result or test for != 1. </p>

</div>
</div>
<a id="aab7593d5374e5eebf774c4d3d551a837" name="aab7593d5374e5eebf774c4d3d551a837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab7593d5374e5eebf774c4d3d551a837">&#9670;&nbsp;</a></span>write() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t IsolatedEthernet::TCPClient::write </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a single byte to the remote host. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The byte to write (can be ASCII or binary).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t The number of bytes written, typically 1.</dd></dl>
<p>This overload does not take a timeout and uses the default timeout of 30 seconds.</p>
<p >It's best to use the overload that takes a buffer and a size. Each byte write is communicated to the W5500 using SPI calls. The W5500 may further buffer the data before assembling it in packets, but using the buffer-based approach is still much faster.</p>
<p >There's a bug in Device OS where the write function can also return a negative error code from <a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#aab7593d5374e5eebf774c4d3d551a837" title="Writes a single byte to the remote host.">write()</a>, however size_t is unsigned, so it tends to return as a very large positive integer instead. Because of this, it's best to ignore the result or test for != 1. </p>

</div>
</div>
<a id="ae2607c60404cbe4562f438a377a55e7e" name="ae2607c60404cbe4562f438a377a55e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2607c60404cbe4562f438a377a55e7e">&#9670;&nbsp;</a></span>write() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t IsolatedEthernet::TCPClient::write </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">system_tick_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a single byte to the remote host. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The byte to write (can be ASCII or binary). </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in milliseconds, or 0 to wait forever</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t The number of bytes written, typically 1.</dd></dl>
<p>It's best to use the overload that takes a buffer and a size. Each byte write is communicated to the W5500 using SPI calls. The W5500 may further buffer the data before assembling it in packets, but using the buffer-based approach is still much faster.</p>
<p >There's a bug in Device OS where the write function can also return a negative error code from <a class="el" href="class_isolated_ethernet_1_1_t_c_p_client.html#aab7593d5374e5eebf774c4d3d551a837" title="Writes a single byte to the remote host.">write()</a>, however size_t is unsigned, so it tends to return as a very large positive integer instead. Because of this, it's best to ignore the result or test for != 1. </p>

</div>
</div>
<a id="ab9195b97274029f693aaddce6c7a0021" name="ab9195b97274029f693aaddce6c7a0021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9195b97274029f693aaddce6c7a0021">&#9670;&nbsp;</a></span>write() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Print::write </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a single byte to the stream or file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The byte to write. All values 0 - 255 are allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="_isolated_ethernet_8h_source.html">IsolatedEthernet.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
